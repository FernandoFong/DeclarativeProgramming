{-Facultad de Ciencias UNAM - Programación Declarativa 2018-2 
      Profesor: C. Moisés Vázquez Reyes
      Ayudante: Enrique Antonio Bernal Cedillo
-}

module Unificacion where

infixr :-> {- Así, el poderador ':->' asocia a la derecha. -}
type Nombre = String

-- Categoría de tipos.
data Tipo = TNat | TBool | X Nombre | Tipo :-> Tipo deriving Eq


instance Show Tipo where
     show t = case t of
            TNat -> "ℕ"
            TBool -> "𝔹"
            X name -> name 
            TNat:->TNat -> "ℕ" ++"->"++"ℕ"
            TNat:->TBool -> "ℕ" ++"->"++"𝔹"
            TNat:->(X name) -> "ℕ"++"->"++name
            TNat:->(t1:->t2) -> "ℕ"++"->("++show t1++"->"++show t2++")"
            TBool:->TBool -> "𝔹" ++"->"++"𝔹"
            TBool:->TNat -> "𝔹" ++"->"++"ℕ"
            TBool:->(X name) -> "Bool"++"->"++name
            TBool:->(t1:->t2) -> "𝔹"++"->("++show t1++"->"++show t2++")"
            (X name):->TNat -> name++"->"++"ℕ"
            (X name):->TBool -> name++"->"++"𝔹"
            (X name1):->(X name2) -> name1++"->"++name2
            (X name):->(t1:->t2) -> name++"->("++show t1++"->"++show t2++")"
            (t1:->t2):->TNat -> "("++show t1++"->"++show t2++")"++"->"++"ℕ"
            (t1:->t2):->TBool -> "("++show t1++"->"++show t2++")"++"->"++"𝔹"
            (t1:->t2):->(X name) -> "("++show t1++"->"++show t2++")"++"->"++name
            (t1:->t2):->(t3:->t4) -> "("++show t1++"->"++show t2++")"++"->("++show t3++"->"++show t4++")"


--Una sustitución es un conjunto de la forma [(xi, Ti)]
type Sust = [(Nombre, Tipo)]


--Elimina sustituciones de la forma [X:=X] en una sustitución.
simpSust :: Sust -> Sust
simpSust [] = []
simpSust ((x,(X y)):xs) = if x == y
                          then simpSust xs
                          else (x, X y) : (simpSust xs)
simpSust (x:xs) = x:(simpSust xs)

--Realiza la composición de dos sustituciones.
compSust :: Sust -> Sust -> Sust
compSust s1 s2 = simpSust(s1 ++ s2)


--Aplica una sustitución a un tipo.
apSustT :: Tipo -> Sust -> Tipo
apSustT t [] = t
apSustT t l1@((x,y):xs) = let z = simpSust l1 in
                            case t of
                              X n -> case y of
                                       TNat -> if x == n
                                               then TNat
                                               else apSustT t xs
                                       TBool -> if x == n
                                                then TBool
                                                else apSustT t xs
                                       X y' -> if x == n
                                               then y
                                               else apSustT t xs
                                       t1 :-> t2 -> if x == n
                                                    then y
                                                    else apSustT t xs
                                                    
                                       
                          
  

--Unifica dos tipos.
unifica :: Tipo -> Tipo -> [Sust]
unifica = error "Te toca"           


--Unifica una lista de tipos.
unificaConj :: [(Tipo,Tipo)] -> [Sust]
unificaConj [] = [[]]
unificaConj ((t1,t2):ts) = [compSust s1 s2 | s1 <- unifica t1 t2, s2 <- unificaConj [(apSustT (fst t) s1,apSustT (snd t) s1) | t <- ts]]



