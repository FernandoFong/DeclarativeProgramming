{-Facultad de Ciencias UNAM - ProgramaciÃ³n Declarativa 2018-2 
      Profesor: C. MoisÃ©s VÃ¡zquez Reyes
      Ayudante: Enrique Antonio Bernal Cedillo
-}

module Unificacion where

infixr :-> {- AsÃ­, el poderador ':->' asocia a la derecha. -}
type Nombre = String

-- CategorÃ­a de tipos.
data Tipo = TNat | TBool | X Nombre | Tipo :-> Tipo deriving Eq


instance Show Tipo where
     show t = case t of
            TNat -> "â„•"
            TBool -> "ð”¹"
            X name -> name 
            TNat:->TNat -> "â„•" ++"->"++"â„•"
            TNat:->TBool -> "â„•" ++"->"++"ð”¹"
            TNat:->(X name) -> "â„•"++"->"++name
            TNat:->(t1:->t2) -> "â„•"++"->("++show t1++"->"++show t2++")"
            TBool:->TBool -> "ð”¹" ++"->"++"ð”¹"
            TBool:->TNat -> "ð”¹" ++"->"++"â„•"
            TBool:->(X name) -> "Bool"++"->"++name
            TBool:->(t1:->t2) -> "ð”¹"++"->("++show t1++"->"++show t2++")"
            (X name):->TNat -> name++"->"++"â„•"
            (X name):->TBool -> name++"->"++"ð”¹"
            (X name1):->(X name2) -> name1++"->"++name2
            (X name):->(t1:->t2) -> name++"->("++show t1++"->"++show t2++")"
            (t1:->t2):->TNat -> "("++show t1++"->"++show t2++")"++"->"++"â„•"
            (t1:->t2):->TBool -> "("++show t1++"->"++show t2++")"++"->"++"ð”¹"
            (t1:->t2):->(X name) -> "("++show t1++"->"++show t2++")"++"->"++name
            (t1:->t2):->(t3:->t4) -> "("++show t1++"->"++show t2++")"++"->("++show t3++"->"++show t4++")"


--Una sustituciÃ³n es un conjunto de la forma [(xi, Ti)]
type Sust = [(Nombre, Tipo)]


--Elimina sustituciones de la forma [X:=X] en una sustituciÃ³n.
simpSust :: Sust -> Sust
simpSust [] = []
simpSust ((x,(X y)):xs) = if x == y
                          then simpSust xs
                          else (x, X y) : (simpSust xs)
simpSust (x:xs) = x:(simpSust xs)

--Realiza la composiciÃ³n de dos sustituciones.
compSust :: Sust -> Sust -> Sust
compSust s1 s2 = simpSust(s1 ++ s2)


--Aplica una sustituciÃ³n a un tipo.
apSustT :: Tipo -> Sust -> Tipo
apSustT t [] = t
apSustT t l1@((x,y):xs) = let z = simpSust l1 in
                            case t of
                              X n -> case y of
                                       TNat -> if x == n
                                               then TNat
                                               else apSustT t xs
                                       TBool -> if x == n
                                                then TBool
                                                else apSustT t xs
                                       X y' -> if x == n
                                               then y
                                               else apSustT t xs
                                       t1 :-> t2 -> if x == n
                                                    then y
                                                    else apSustT t xs
                                                    
                                       
                          
  

--Unifica dos tipos.
unifica :: Tipo -> Tipo -> [Sust]
unifica = error "Te toca"           


--Unifica una lista de tipos.
unificaConj :: [(Tipo,Tipo)] -> [Sust]
unificaConj [] = [[]]
unificaConj ((t1,t2):ts) = [compSust s1 s2 | s1 <- unifica t1 t2, s2 <- unificaConj [(apSustT (fst t) s1,apSustT (snd t) s1) | t <- ts]]



